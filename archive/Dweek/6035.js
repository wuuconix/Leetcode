/**
 * 6035. 选择建筑的方案数
 * 中等
 * 给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：

s[i] = '0' 表示第 i 栋建筑是一栋办公楼，
s[i] = '1' 表示第 i 栋建筑是一间餐厅。
作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。

比方说，给你 s = "001101" ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 "011" ，有相邻两栋建筑是同一类型，所以 不合 题意。
请你返回可以选择 3 栋建筑的 有效方案数 。

示例 1：

输入：s = "001101"
输出：6
解释：
以下下标集合是合法的：
- [0,2,4] ，从 "001101" 得到 "010"
- [0,3,4] ，从 "001101" 得到 "010"
- [1,2,4] ，从 "001101" 得到 "010"
- [1,3,4] ，从 "001101" 得到 "010"
- [2,4,5] ，从 "001101" 得到 "101"
- [3,4,5] ，从 "001101" 得到 "101"
没有别的合法选择，所以总共有 6 种方法。
示例 2：

输入：s = "11100"
输出：0
解释：没有任何符合题意的选择。
 

提示：

3 <= s.length <= 105
s[i] 要么是 '0' ，要么是 '1' 。
 * @param {string} s
 * @return {number}
 * 双周赛的时候没有想出更低时间复杂度的做法，一直是O(n^2) 跑到70几个样例就超时了。
 * 这道题的字符串中只有0和1，我们去这个字符串里选出3个，如果是101或者010就算一种方法。
 * 那我们拿最简单的 010 这个字符串看，如何求出一共有几种可能性呢？
 * 很显然，这只有一种可能性，怎么算的呢？我们看中间这个1，它左边有一个0，右边有一个0，相乘，就是方法数，即 1 * 1 = 1
 * 我们拿个更复杂的举例子，00100，很显然，这个方法数就是 2 * 2 = 4
 * 所以关键就是找中间那个数，然后求两边的个数。
 * 我们再来最后一个复杂的例子  001101
 * 这个就不容易看出来了，算法流程是这样的，我们先看第一个0，它左边的1是0，右边的1是3，为答案贡献的方法个数就是 0 * 3 = 0
 * 第二个0贡献也是0，第三个1贡献 2 * 1 = 2。第四个1贡献 2 * 1 = 2。第五个0贡献 2 * 1 = 2。第六个1贡献 3 * 0 = 0.
 * 所以总数就是 2 + 2 + 2 = 6
 * 看懂这种求法，我们就很容易写出程序了。
 */
var numberOfWays = function(s) {
    let zeroCount = s.length - s.replace(/0/g, "").length //记录s中0的个数
    let oneCount = s.length - s.replace(/1/g, "").length //记录s中1的个数
    let zeroPre = 0, onePre = 0, res = 0
    for (let num of s) {
        if (num == "1") { //把它想成中间的数，则 0 1 0。那么这个1贡献的方案就等于 它前面0的个数 * 它后面0的个数
            res += (zeroPre * (zeroCount - zeroPre))
            onePre += 1
        } else {
            res += (onePre * (oneCount - onePre))
            zeroPre += 1
        }
    }
    return res
};

let s = "0001100100"
console.log(numberOfWays(s));