/**
 * 剑指 Offer II 020. 回文子字符串的个数
 * 中等
 * 给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

示例 1：

输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：

输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
 
提示：

1 <= s.length <= 1000
s 由小写英文字母组成
 * @param {string} s
 * @return {number}
 * 通过枚举回文字符串中间字符的方式，把枚举的时间复杂度降低到O(n)。
 * 然后从中心开始拓展，如果两边的值是一样的，说明多了一个回文串，这里的时间复杂度也是O(n)。
 * 故总的时间复杂度是O(n^2)。这道题的字符长度不是很大，所以可以通过。
 * 84 ms 50.48%
 * 41.3 MB 86.72%
 * 枚举中心是这样的， 比如 abcd，它是这样开始枚举的，因为一个字符也算 回文字符，所以我们的中心首先是 aa
 * 然后是 ab ，然后 bb ，bc，cc，cd，dd
 * 可以看到，4位的字符，我们枚举它中心的情况一共有 7种，即2 n - 1，所以是 O(n)级别。
 * 	84 ms 	41.3 MB
 */
var countSubstrings = function(s) {
    s = s.split("") //方便按照下标取字符
    let n = s.length, ans = 0
    for (let i = 0; i < 2 * n - 1; i++) {
        let l = Math.floor(i / 2), r = Math.floor(i / 2) + i % 2
        while (l >= 0 && s[l] == s[r]) {
            l--
            r++
            ans++
        }
    }
    return ans
};

/* 68 ms 83.33%
42.1 MB 55.80% 
马拉车算法，一种在回文串领域可以达到O(n)的算法。
它的思想还是上一个函数的中心拓展。
然后马拉车算法在两个地方进行了优化。
首先，因为我们要考虑中心是单字符还是双字符，这很麻烦，马拉车直接把所有字符前面加上一个#。
比如 aba 我们需要 考虑 a为中心， ab 为中心，ba为中心，a为中心。
如果加上#后，变成了 #a#b#a。这让我们只需要线性遍历为中心即可，即# 为中心，a为中心，#为中心。。。。
实际上#为中心代表的就是 两个字符为中心的情况，比如第二个#为中心的时候，实际上就模拟了 ab为中心的时候。
马拉车还有一个优化的点就是 中心拓展的半径不是每个都从1开始了。
因为回文串嘛，就是有对称性。假设我们之前已经记录到了一个回文串，比如 aabbaa。现在我们考虑倒数第二个 a为中心的情况，我们可以发现，倒数第二个a
的回文串半径起点完全可以和开头第二个a的半径开始，再网上加去尝试，所以我们每次中心拓展的起点就优化了。*/
var countSubstrings = function(s) {
    let t = ["$", "#"] //$为开始标志
    for (let letter of s) {
        t.push(letter)
        t.push("#")
    }
    t.push("!") //!为结束标志
    let n = t.length
    let iMax = 0, rMax = 0 //iMax表示右边界最大的对应的中心坐标，rMax代表最大的右边界坐标
    let f = new Array(n).fill(0) //记录每个下标的最大半径
    let ans = 0
    for (let i = 0; i < n; i++) {
        f[i] = i <= rMax ? Math.min(f[2 * iMax - i], rMax - i + 1) : 1 //f[2 * iMax - i]是 i 关于 iMax对称的点。 rMax - i + 1 是 rMax到i之间的距离，我们需要满足 半径先不要超过最大半径，因为如果超过了，左边对称点就和右边的点不再同步了，数据不再有效。
        while (t[i + f[i]] == t[i - f[i]]) {
            f[i]++
        }
        if (i + f[i] - 1 > rMax) {
            rMax = i + f[i] - 1 //更新右边界
            iMax = i //更新对应的中间节点
        }
        ans += Math.floor(f[i] / 2)
    }
    return ans
};

let s = "aaa"
console.log(countSubstrings(s));