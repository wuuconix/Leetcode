/**
 * 剑指 Offer II 001. 整数除法
 * 简单
 * 给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。

注意：

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1

示例 1：

输入：a = 15, b = 2
输出：7
解释：15/2 = truncate(7.5) = 7
示例 2：

输入：a = 7, b = -3
输出：-2
解释：7/-3 = truncate(-2.33333..) = -2
示例 3：

输入：a = 0, b = 1
输出：0
示例 4：

输入：a = 1, b = 1
输出：1
 

提示:

-231 <= a, b <= 231 - 1
b != 0
 * @param {number} a
 * @param {number} b
 * @return {number}
 */

/* 暴力法，利用减法模拟除法，超时。 */
var divide = function(a, b) {
    let res = 0
    let overflow = 2 ** 31 - 1
    if (a == 0)
        return 0
    if (a < 0)
        return divide(-a, -b)
    if (b > 0) {
        while (a >= b) {
            a -= b
            res++
            if (res >= 2 ** 31)
                return overflow
        }
    } else if (b < 0) {
        while (a >= -b) {
            a += b
            res--
            if (res < -(2 ** 31))
                return overflow
        }
    }
    return res
};

/* 这offer2 真是当头一棒啊，这他妈是简单？
首先我们如何求出商呢？我们可以用减法来简单模拟。
比如 15 / 2 等于 7，实际就是不断减去2，直到减去7次，15变成1了， 这时候1 已经 小于 2了，不能再减了，我们得到答案 7
但是这样在除数很小，但是被除数很大的时候就会造成恐怖的事件复杂度，比如 2^31 / 1 这种情况，我们需要不断减去 2 ^ 31个1才能得到答案，肯定会超时了。
所以我们就有了一个质朴的想法，每次减1个很慢，如果1次减去很多个1呢？
所以我们就把减去多少个除数进行一个指数爆炸，第一个如果减去 1个除数ok，下一个就减去 2个，然后4个，然后8个，直到发现 被除数已经小于爆炸后的被除数，
这个时候，我们利用指数的出来的倍数实际上就是 代表了 a 可以减去多少个b。我们将res加上这个倍数。
然后由于这个倍数是很大的，a减去这么多后，还可能还可以继续减，所以我们需要不断循环，每次循环都让倍数从1开始。
直到a < b
因为用到了指数，事件复杂度急剧下降到了 O(logn)
72 ms 82.48%
42.8 MB 58.76%
 */
var divide = function(a, b) {
    if (a == 0)
        return 0
    if (a < 0)
        return divide(-a, -b)
    let neg = false
    if (b < 0) { //把b是负数的情况直接转化为正数来考虑
        b = -b
        neg = true
    }
    let res = 0
    while (a >= b) {
        let i = 1
        while (a > (2 ** i) * b) //几何提高倍数，查看a什么时候小于几何倍数下的b  这里为什么不用 1 << i 来几何爆炸呢？因为 1 << 31就是负数了，之后就会产生错误
            i++
        res += 2 ** (i - 1) //因为我们的商的概念就类似于 a 等于 几个 b。现在我们可以说 res 中需要包含  1 << (i - 1) 个b
        if ((res >= 2 ** 31 && !neg) || (res > 2 ** 31 && neg)) //溢出处理
            return 2 ** 31 - 1
        a -= (2 ** (i - 1)) * b //a减去这些个b
    }
    return neg ? -res : res
};

let a = -2147483648, b = -1
console.log(divide(a, b));